# 后台开发，面经准备



### 自我介绍

​	

面试官你好，本人名字叫做姚文振，就读于天津大学计算机科学与技术专业本科三年级；在大学期间，我曾和同学组队参与过市级大创项目《安卓应用权限异常挖掘与分析》，在团队合作方面能够与队友良好沟通交流；然后在课程方面，我也学习过计算机网络、操作系统、数据原理等基础课程，有一定的基础。本次申请的职位是后台开发实习生。 



## C++







### C++内存5区（4区），程序的内存分配‘



- 栈区
  - 由编译器自动分配释放  ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈
- 堆区
  - 程序员自己申请销毁
- 代码区
  - 存放函数二进制代码
- 全局区，静态常量区
  - 存放静态变量，全局变量
- 文字常量区
  - 常量字符串







## 计算机网络 



| 物理层     | 通过媒介传输比特，确定机械及电气规范（比特 Bit）    | RJ45、CLOCK、IEEE802.3（中继器，集线器）            |
| ---------- | --------------------------------------------------- | --------------------------------------------------- |
| 数据链路层 | 将比特组装成帧和点到点的传递（帧 Frame）            | PPP、FR、HDLC、VLAN、MAC（网桥，交换机）            |
| 网络层     | 负责数据包从源到宿的传递和网际互连（包 Packet）     | IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器） |
| 运输层     | 提供端到端的可靠报文传递和错误恢复（ 段Segment）    | TCP、UDP、SPX                                       |
| 会话层     | 建立、管理和终止会话（会话协议数据单元 SPDU）       | NFS、SQL、NETBIOS、RPC                              |
| 表示层     | 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） | JPEG、MPEG、ASII                                    |
| 应用层     | 允许访问OSI环境的手段（应用协议数据单元 APDU）      |                                                     |

### 传输层 TCP，UDP



#### TCP和UDP的区别、特点

TCP 面向连接，确保可靠传输，有拥塞控制，流量控制等功能

面向字节流，只能一对一

使用场景：HTTP，邮件发送，文字传输等，TELNET



UDP 不面向连接，不确保可靠传输，无 

面向报文，可以多对多，一对多，多对一

使用场景：DNS、视频、语音、直播等，DHCP



#### TCP为什么要三次握手，建立连接

> 三次握手的过程
>
> 假设 A 为客户端，B 为服务器端。
>
> - 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
> - A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
> - B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
> - A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
> - B 收到 A 的确认后，连接建立。
>

**三次握手的原因**

- 【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）

> [Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信}](https://groups.google.com/forum/#!msg/pongba/kF6O7-MFxM0/5S7zIJ4yqKUJ)

- 【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。

> [知乎 . TCP 为什么是三次握手，而不是两次或四次？](https://www.zhihu.com/question/24853633/answer/115173386)

- 【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。



防止失效的连接到达服务端，客户端还会重传，建立两个连接，造成不必要的资源浪费。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。



#### TCP为什么要四次挥手，断开连接

> 1. 客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；
> 2. 服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；
> 3. 客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；
> 4. 服务端继续发送之前没发完的数据给客户端；
> 5. 服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；
> 6. 客户端收到服务端的 FIN+ACK，并回复 ACK 给客户端（同意释放从服务端到客户端的连接）；
> 7. 服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。

- 问题一、 为什么建立连接要三次握手，断开要四次挥手

  【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。

- 问题二、为什么释放时，FIN和ACK需要分开发送

  【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。

- 问题三、为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？

  1. 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。
  2. 防止已失效的连接请求报文段出现在下一连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。



#### TCP实现可靠传输，不丢包，拆包沾包

> TCP是“流”协议，所谓“流”协议，就是没有界限，没有分割的一串数据。TCP会根据缓冲区实际情况进行划分，一个完整的包可能会拆分成多个包进行发送，也有可能把多个小包封装成一个大的数据包发送，这就是TCP粘包/拆包。

确认序号，超时重传

​	首先，每一个TCP报文段都有自己序号，当超过等待时间没有收到确认信息，重传报文段。实现可靠传输

**两次duplicated ACK肯定是乱序造成的！**

**丢包肯定会造成三次duplicated ACK!**

**应用程序写入的字节大小大于套接字发送缓冲区的大小**，会**发生拆包**现象，而**应用程序写入数据小于套接字缓冲区大小，**网卡**将应用多次写入的数据发送到网络**上，这将会发生粘包现象；

解决办法：

​	消息定长，浪费资源；

​	尾部加特殊分隔符；

​	用特殊的消息头、消息尾。

### 应用层





#### 浏览器输出URL到响应页面的全过程



1. 浏览器对URL进行解析 - HTTP协议 - 应用层 - TCP

   - 确定Web服务器和文件名

2. IP地址查询- DNS - 应用层协议 - UDP 

   - 查询服务器域名对应的IP地址
   - 分级查询‘

   > 接下来，将HTTP的传输工作交给底层的协议栈

3. 可靠传输 - TCP - 传输层

   - 三次握手，建立连接

4. 远程定位 - IP - 网络层

   - TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成**网络包**发送给通信对象。
   - 路由器路由，最长前缀匹配

5. 两点定位 - MAC - 链路层

   - 在 MAC 包头里需要**发送方 MAC 地址**和**接收方目标 MAC 地址**，用于**两点之间的传输**。
   - 通过ARP协议获取MAC地址，ARP是网络层协议

6. 网卡- 出口 - 物理层

   - 数字信号转化为电信号

7. 送别者 - 交换机

- 交换机的设计是将网络包**原样**转发到目的地。交换机工作在 MAC 层，也称为**二层网络设备**。
- 交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，**交换机的端口不具有 MAC 地址**
- MAC地址表， 自学习

8. 网关 - 路由器

   - 因为**路由器**是基于 IP 设计的，俗称**三层**网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；

   - 当转发包时，首先路由器端口会接收发给自己的以太网包，然后**路由表**查询转发目标，再由相应的端口作为发送方将以太网包发送出去。

   - 完成包接收操作之后，路由器就会**去掉**包开头的 MAC 头部。

     **MAC 头部的作用就是将包送达路由器**，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会**被丢弃**。

   - 网络包传输的过程中，**源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址**，因为需要 MAC 地址在以太网内进行**两个设备**之间的包传输。

9. 客户端解包

   - 自底向上去除头部



#### HTTP报文组成

- 请求报文
  - 第一行是包含了请求方法、URL、协议版本；
  - 接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。包括域名，编码，客户端，连接状态等
  - 一个空行用来分隔首部和内容主体 Body
  - 最后是请求的内容主体
- 响应报文
  - 第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了
  
  - 接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。包括域名，编码，客户端，连接状态等，
  
    Host， content-lengt， content-type， date
  
  - 一个空行用来分隔首部和内容主体 Body
  
  - 最后是响应的内容主体

#### HTTP方法

- **GET**
- **POST**
- **HEAD**
- **PUT**
- **DELETE**

#### HTTP状态码

| 状态码 | 类别                             | 含义                       |
| ------ | -------------------------------- | -------------------------- |
| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求出错         |



- 200  OK
- 400  Bad Request
- 401  **Unauthorized**
- 402  Forbidden 请求被拒绝
- 403  Not Found

- **500 Internal Server Error** ：服务器正在执行请求时发生错误。
- **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。



#### DDOS 攻击

全称Distributed Denial of Service，中文意思为“分布式拒绝服务”，就是利用大量合法的分布式服务器对目标发送请求，从而导致正常合法用户无法获得服务。通俗点讲就是利用网络节点资源如：IDC服务器、个人PC、手机、智能设备、打印机、摄像头等对目标发起大量攻击请求，从而导致服务器拥塞而无法对外提供正常服务，只能宣布game over，详细描述如下图所示：







## 操作系统



### 进程、线程管理



#### 进程、线程的区别特点



1. 线程是进程的一部分，一个进程能够拥有多个线程
2. 资源方面
   - 进程是资源分配的最小单位，线程可以访问其所属进程的资源
3. 调度方面
   - 线程是独立调度的最小单位，同一进程内的线程切换时，不会造成进程切换，反之。
4. 系统开销方面
   - 进程的创建、切换、销毁的开销要大于线程
   - 因为进程的切换涉及到了内存空间，IO的设备，页的置换，而线程的切换只需要保存设置少量寄存器，开销小
5. 并行方面
   - 多进程可以使用多个CPU核，适合多机，多线程只能用到单核

6. 通信方面
   - 进程之间的通信需要借助IPC (`进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。`)，同一进程内的线程可以借助共享内存进行通信。

#### 进程之间的通信

1. 管道 pipe

   优点：使用简单，

   缺点：缓冲区有限

   - 有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信
     - 优点：可以实现任意关系的进程间的通信
     - 缺点：
       1. 长期存于系统中，使用不当容易出错
       2. 缓冲区有限
     
   - 无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）
     - 优点：简单方便
     - 缺点：
       1. 局限于单向通信
       2. 只能创建在它的进程以及其有亲缘关系的进程之间
       3. 缓冲区有限
     
     >其实，**所谓的管道，就是内核里面的一串缓存**。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。 
     >
     > 使用fork创建子进程，**创建的子进程会复制父进程的文件描述符**，这样就做到了两个进程各有两个「fd[0]与fd[1]」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。

2. 信号量

   信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问

3. 信号

4. 消息队列

   是消息的链表，存放在内核中并由消息队列标识符标识，通过系统调用实现任意进程之间的通信

5. 共享存储

   映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问

6. 套接字`socket`

   可用于不同计算机间的进程通信



#### 僵尸进程，父子进程之间通信

- 什么是孤儿进程：

  一个父进程退出，而他的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程，孤儿进程将被init进程(进程号为1的进程)所收养，并由init进程对它们完成状态收集工作。

- 什么是僵尸进程：

  一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用`wait`/`waitpid`获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。

- 危害：

  进程退出时，内核释放其占有的资源，但是仍然为其保留了一定的信息，比如进程号，如果父进程不调用`wait`/`waitpid`去释放，没有多余的进程号，进程僵死。

- 解决办法：

  - 杀死父进程，僵尸进程变为孤儿进程，由操作系统回收
  - 使用信号机制，子进程释放时，发送信号给父进程，让其调用wait释放
  - `fork()`两次，产生子子进程

#### 线程之间的通信

1. 锁机制，包括互斥锁，共享锁
2. 信号量机制
3. 信号机制
4. 屏障（`barrier`）



#### 进程之间私有和共享的资源

- 私有：地址空间、堆、全局变量、栈、寄存器
- 共享：代码段，公共数据，进程目录，进程 ID

#### 线程之间私有和共享的资源

- 私有：线程栈，寄存器，程序计数器
- 共享：堆，地址空间，全局变量，静态变量



### 内存管理



#### 栈和堆的区别

1. 申请方法
   - 栈，系统自己分配，销毁
   - 堆，程序员通过new，malloc

2. 大小限制
   
   - 栈小堆大
   
3. 内存形式
   - 栈，连续存储，先进后出，存储地址减小
   - 堆，不连续存储，产生碎片，系统通过链表管理存储空间，存储地址增加
   
   
   
#### 内核态 和 用户态

我们可以看出来通过**系统调用**将Linux整个体系分为用户态和内核态（或者说内核空间和用户空间）。那内核态到底是什么呢？其实从本质上说就是我们所说的内核，它是一种**特殊的软件程序**，特殊在哪儿呢？**控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行**。

用户态就是提供应用程序运行的空间，为了使应用程序访问到内核管理的资源例如CPU，内存，I/O。内核必须提供一组通用的访问接口，这些接口就叫**系统调用。**



#### IO复用， selec， poll， epoll

同时监控多个进程描述符，等待成为就需状态，完成IO操作

区别：

- select 可以对FD进行修改
- select 默认监控有限1024， poll无
- epoll仅适用于LINUX，没有描述符数量限制，多线程更加友好

## 数据库





### 事务



#### 什么是事务

事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。

<img src="https://camo.githubusercontent.com/57b5cb6a1cc1d6b9127ce54bb4f7920170bb86c2d4eb273f36989cee1299fe78/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323233373932352e706e67" alt="img" style="zoom:50%;" />

#### 事务的四大特性 ACID



1. `Atomicity `原子性

   事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

   回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

2. `Consistency`一致性

   数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。

3. `Isolation`隔离性

   一个事务所做的修改在最终提交以前，对其它事务是不可见的。

4. `Durability`持久性

   一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

   系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。



#### 事务的并发一致性问题

并发条件下，事务的隔离性很难保证，会出现很多并发一致性问题。

问题：

- 丢失修改

- 脏读
- 不可重复读
- 幻读

#### 隔离机制

- 读未提交

- 读已提交

- 可重复读

- 串行化

  

<img src="https://camo.githubusercontent.com/1632a88a3a4fa7954026cb939edf2f8a30bb5d60a1bce4921c7e0d0e4d245739/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232333430303738372e706e67" alt="img" style="zoom: 67%;" />

### 数据库索引



#### 索引分类

- 普通索引
  这是最基本的索引类型，而且它没有唯一性之类的限制。
- 唯一性索引
  这种索引和前面的“普通索引”基本相同，但有一个区别：索引列的所有值都只能出现一次，即必须唯一。

- 主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型，主键索引要求主键 中的每个值都是唯一的

- 聚簇索引：表中各行的物理顺序与键值的逻辑顺序相同，每个表只能有一个

- 非聚簇索引：非聚簇索引指定表的逻辑顺序，数据存储在一个位置，索引存储在另外一个位置，索引中包含指向数据存储位置的指针

  

### 关系数据库理论，范式



#### 函数依赖的概念

记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。

如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。

对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。

对于 A->B，B->C，则 A->C 是一个传递函数依赖。

#### 异常

不符合范式的关系，会产生很多异常，主要有以下四种异常：

- 冗余数据：例如 `学生-2` 出现了两次。
- 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。
- 删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 `课程-1` 需要删除第一行和第三行，那么 `学生-1` 的信息就会丢失。
- 插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。

#### 范式

高级别的范式依赖于低级别的范式

1. 1NF

   属性不可分

2. 2NF

   每个非主属性必须完全函数依赖于主属性。（可以通过分解来满足）

3. 3NF

   完全函数依赖不能是通过传递函数依赖



### Mysql索引

#### 聚簇索引和非聚簇索引

- 聚簇索引

  - **InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分；**

  - 一般是主键，没有则隐式指定非空的唯一索引
  - 优点：访问快，查找快，排序查找、范围查找快
  - 插入速度依赖于插入顺序，修改主键代价高

- 非聚簇索引（辅助索引、符合索引、唯一索引）

  - **我们日常工作中，根据实际情况自行添加的索引都是辅助索引，辅助索引就是一个为了需找主键索引的二级索引，现在找到主键索引再通过主键索引找数据；**

  - Innodb使用的是聚簇索引，MyISam使用的是非聚簇索引

- 聚簇索引和非聚簇索引的区别

  - 聚簇索引的叶子节点存放的是主键值和数据行，**支持覆盖索引**；二级索引的叶子节点存放的是主键值或指向数据行的指针。

  由于节子节点(数据页)只能按照一颗B+树排序，故**一张表只能有一个聚簇索引**。辅助索引的存在不影响聚簇索引中数据的组织，所以一张表可以有多个辅助索引

  - 覆盖索引：可只通过索引而不通过数据表获得数据

    

#### 数据库索引失效的情况（索引优化）

使用EXPLAIN分析查询情况

1. 使用了不等于操作符
2. WHERE 中进行了NULL值判断
3. OR使用不当，必须两边都有索引
4. LIKE 模糊查询
5. 索引大量重复，mysql认为全表查询比索引快





### 索引的数据结构



#### 哈希索引

哈希索引能以 O(1) 时间进行查找，但是失去了有序性：

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

`InnoDB `存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

- 解决哈希冲突的办法
  - 链地址法
  - 开放地址法
  - 再哈希法

#### B+ Tree 索引



`B Tree `指的是 `Balance Tree`，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。

`B+ Tree` 是基于 `B Tree` 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。

在 `B+ Tree` 中，一个节点中的 $key$ 从左到右非递减排列，如果某个指针的左右相邻 $  key$ 分别是 $key_i$ 和 $key_{i+1}$，且不为 null，则该指针指向节点的所有 key 大于等于 $key_i$ 且小于等于 $key_{i+1}$。



- 操作

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。



#### **为什么索引结构默认使用B+树，而不是B-Tree，Hash哈希，二叉树，红黑树?**

- Hash哈希，只适合等值查询，不适合范围查询。

- 一般二叉树，可能会特殊化为一个链表，相当于全表扫描。

- 红黑树，是一种特化的平衡二叉树，MySQL 数据量很大的时候，索引的体积也会很大，内存放不下的而从磁盘读取，树的层次太高的话，读取磁盘的次数就多了。

- B-Tree，叶子节点和非叶子节点都保存数据，相同的数据量，B+树更矮壮，也是就说，相同的数据量，B+树数据结构，查询磁盘的次数会更少，便于范围查询

  

#### **B-树和B+树的区别**

- B-树内部节点是保存数据的;而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。
- B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是。
- 查找过程中，B-树在找到具体的数值以后就结束，而B+树则需要通过索引找到叶子结点中的数据才结束
- B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。

#### Mysql 代码题

1. 设计学生成绩数据库，并写出查询语文成绩top3的人。gg，懵逼了。忘了联合主键能不能连表查询了，不敢说

   